applyStylesToRootElementOfYDF_Component(defaultSelector, areThemesCSS_ClassesCommon, themes)

  commonThemesCSS_Classes = YDF_Array-create()

  for theme in values(themes)

    YDF_Array-appendElementsIf(
      commonThemesCSS_Classes,
      isNonEmptyString(theme.componentIndependentCSS_Class),
      theme.componentIndependentCSS_Class
    )

  hasCommonCSS_Class = YDF_Array-isIncludes(commonThemesCSS_Classes, theme.componentIndependentCSS_Class)


  if selector() == "&" || selector() == "" || hasCommonCSS_Class

    {defaultSelector}

      {block}

  else

    {block}


provideDefaultSelectorWhenRootAndApply(defaultSelector)

  if selector() == "&" || selector() == ""

    {defaultSelector}

      {block}

  else

    {block}


getCurrentSelectorSubstitutingRoot(defaultSelector)

  return selector() == "&" || selector() == "" ? defaultSelector : selector()


applyComponentThemes(compoundParameter, restParameters__MUST_NOT_BE...)

  validateObjectTypeParameter({
    mixinOrFunctionName: "applyComponentThemes",
    targetParameterNumber: 1,
    targetParameter: compoundParameter,
    schema: {
      CSS_Namespace: {
        type: DataTypes.string,
        required: true,
        minimalCharactersCount: 1
      },
      areThemesCSS_ClassesCommon: {
        type: DataTypes.boolean,
        defaultValue: false
      },
      themeIndependentGeometricVariations: {
        type: DataTypes.boolean,
        defaultValue: false
      }
    },
    followingParametersWhichMustNotBe: restParameters__MUST_NOT_BE
  })

  CSS_Namespace = compoundParameter.CSS_Namespace
  themes = compoundParameter.themes
  areThemesCSS_ClassesCommon = compoundParameter.areThemesCSS_ClassesCommon
  themeIndependentGeometricVariations = compoundParameter.themeIndependentGeometricVariations

  // [ Theory ] If make "hasThemeIndependentGeometricVariationsBeenApplied" boolean, even its value will be changed
  //    inside `applyTheme`, when `applyTheme` will be called again, the value of
  //    "hasThemeIndependentGeometricVariationsBeenApplied" will return to initial one.
  hasThemeIndependentGeometricVariationsBeenApplied = { value: false }

  // [ Stylus theory ] Functions in object are allowed but must be decomposed to be invoked.
  applyGeometricVariation = compoundParameter.applyGeometricVariation
  applyDecorativeVariation = compoundParameter.applyDecorativeVariation


  applyTheme(themeName, theme) {

    nonEmptyGeometricVariationsCount = getObjectNonNullValuesCount(theme.geometricVariations)
    mustApplyGeometricVariations = !(themeIndependentGeometricVariations && hasThemeIndependentGeometricVariationsBeenApplied.value);

    if(mustApplyGeometricVariations) {

      // [ Theory ] Every value could be set to null by user.
      iterateObjectSkippingNullValues(theme.geometricVariations, @(geometricVariationName, geometricVariation) {

        if (nonEmptyGeometricVariationsCount == 1) {

          if (themeIndependentGeometricVariations) {
            / {
              applyGeometricVariation(themeName, geometricVariationName, geometricVariation)
            }
          } else {
            applyGeometricVariation(themeName, geometricVariationName, geometricVariation)
          }

        } else {

          geometricVariationCSS_Class = buildBEM_ClassName({
            block: CSS_Namespace,
            modifier: capitalizeFirstLatinCharacter(geometricVariationName) + "GeometricVariation"
            elementSeparator: "-",
            modifierSeparator: "__"
          })

          if (themeIndependentGeometricVariations) {
            /.{geometricVariationCSS_Class} {
              applyGeometricVariation(themeName, geometricVariationName, geometricVariation)
            }
          } else if (selector() == "&" || selector() == "") {
            .{geometricVariationCSS_Class} {
              applyGeometricVariation(themeName, geometricVariationName, geometricVariation)
            }
          } else {
            &.{geometricVariationCSS_Class} {
              applyGeometricVariation(themeName, geometricVariationName, geometricVariation)
            }
          }
        }
      })

    }

    if (themeIndependentGeometricVariations) {
      hasThemeIndependentGeometricVariationsBeenApplied.value = true
    }

    // [ Theory ] Every value could be set to null by user.
    iterateObjectSkippingNullValues(theme.decorativeVariations, @(decorativeVariationName, decorativeVariation) {

      nonEmptyDecorativeVariationsCount = getObjectNonNullValuesCount(theme.decorativeVariations)

      if (nonEmptyDecorativeVariationsCount == 1) {

        applyDecorativeVariation(themeName, decorativeVariationName, decorativeVariation)

      } else {

        decorativeVariationCSS_Class = buildBEM_ClassName({
          block: CSS_Namespace,
          modifier: capitalizeFirstLatinCharacter(decorativeVariationName) + "DecorativeVariation",
          elementSeparator: "-",
          modifierSeparator: "__"
        })

        if (selector() == "&" || selector() == "" || areThemesCSS_ClassesCommon) {
          .{decorativeVariationCSS_Class} {
            applyDecorativeVariation(themeName, decorativeVariationName, decorativeVariation)
          }
        } else {
          &.{decorativeVariationCSS_Class} {
            applyDecorativeVariation(themeName, decorativeVariationName, decorativeVariation)
          }
        }
      }
    })
  }


  nonEmptyThemesCount = getObjectNonNullValuesCount(themes)

  iterateObjectSkippingNullValues(themes, @(themeName, theme) {

    if (nonEmptyThemesCount == 1) {

      applyTheme(themeName, theme)

    } else {

      if (areThemesCSS_ClassesCommon) {

        if (!isNonEmptyString(theme.componentIndependentCSS_Class)) {
          error(
            buildString(
              "The themes of the component with CSS namespace '${ CSS_Namespace }' has been set to external however " +\
              "the property 'componentIndependentCSS_Class' on the theme specification has not been defined. "+\
              "Please define it with non-empty string.",
              {
                themeName: themeName,
                CSS_Namespace: CSS_Namespace
              }
            )
          )
        }

        themeCSS_Class = theme.componentIndependentCSS_Class

      } else {

        themeCSS_Class = buildBEM_ClassName({
          block: CSS_Namespace,
          modifier: capitalizeFirstLatinCharacter(themeName) + "Theme",
          elementSeparator: "-",
          modifierSeparator: "__"
        })

      }

      .{themeCSS_Class} {
        applyTheme(themeName, theme)
      }

    }
  })


provideComponentsPositionalRelationship(definitions = {})

  iterateAssociativeArray(definitions, @(componentCSS_Namespace, definitionsForTargetComponent) {

    if isNotNull(definitionsForTargetComponent.withTypography) {

      iterateObjectSkippingNullValues(definitionsForTargetComponent.withTypography, @(presetName, preset) {

        if isNotNull(preset.typographyDefinition) && isNotNull(preset.spacingDefinitions) {

          elementsKeysAndCSS_ClassesMap = generateTypographyElementsKeysAndCSS_ClassesMap(preset.typographyDefinition)

          for elementKey, spacingDefinitions in preset.spacingDefinitions {

            TARGET_ELEMENT_CSS_CLASS = elementsKeysAndCSS_ClassesMap[elementKey]

            PositionalRelationship({
              definitions: ("." + componentCSS_Namespace {
                retireFromIt: { y: spacingDefinitions.retireFromComponent },
                pushItFromSelf: { y: spacingDefinitions.pushComponentFromSelf }
              }),
              referenceElementSelector: "." + TARGET_ELEMENT_CSS_CLASS
            })
          }
        }
      })
    }

    if (isNotNull(definitionsForTargetComponent.withOtherComponents)) {

      iterateAssociativeArray(definitionsForTargetComponent.withOtherComponents, @(targetCSS_Class, spacingDefinitions) {

        PositionalRelationship({
          definitions: ("." + targetCSS_Class {
            retireFromIt: { y: spacingDefinitions.retireFromTarget },
            pushItFromSelf: { y: spacingDefinitions.pushTargetFromSelf }
          }),
          referenceElementSelector: "." + componentCSS_Namespace
        })
      })
    }
  })


extractAndValidateObjectProperties(compoundParameter, restParameters__MUST_NOT_BE...)

  validateObjectTypeParameter({
    mixinOrFunctionName: "extractAndValidateObjectProperties",
    targetParameterNumber: 1,
    targetParameter: compoundParameter,
    schema: {
      targetObjectName: {
        type: DataTypes.string,
        required: true,
        minimalCharactersCount: 1
      }
    },
    followingParametersWhichMustNotBe: restParameters__MUST_NOT_BE
  })

  targetObject = compoundParameter.targetObject
  targetObjectName = compoundParameter.targetObjectName
  extracts = compoundParameter.extracts

  extractedVariables = {}

  for variableName, variableSpecification in extracts

    variableFinalName = isNonEmptyString(variableSpecification.newName) ? variableSpecification.newName : variableName
    targetValue = getObjectValueByDotSeparatedPathSafely(targetObject, variableSpecification.dotSeparatedPath)

    if isNull(targetValue)

      if variableSpecification.required

        error(
          buildString(
            "The property '${dotSeparatedPath}' must be defined on '${targetObjectName}' while actually is null.",
            {
              dotSeparatedPath: variableSpecification.dotSeparatedPath,
              targetObjectName: targetObjectName
            }
          )
        )


      if isNotNull(variableSpecification.requiredIf)

        // [ Stylus theory ] Functions in objects could be called if and only if destructured
        predicate = variableSpecification.requiredIf.predicate

        if (isTrue(predicate(targetObject))) {
          error(
            buildString(
              "The property '${dotSeparatedPath}' must be defined on '${targetObjectName}' when ${requirementConditionDescription}.",
              {
                dotSeparatedPath: variableSpecification.dotSeparatedPath,
                targetObjectName: targetObjectName,
                requirementConditionDescription: variableSpecification.requiredIf.conditionDescription
              }
            )
          )
        }


      else if (\
        isNonEmptyString(variableSpecification.mustBeInsteadOf) &&\
        isNull(getObjectValueByDotSeparatedPathSafely(targetObject, variableSpecification.mustBeInsteadOf))
      )

        error(
          buildString(
            "The property '${targetPropertyDotSeparatedPath}' must be defined on '${targetObjectName}' when " +\
            "'${oppositePropertyName}' is null.",
            {
              targetPropertyDotSeparatedPath: variableSpecification.dotSeparatedPath,
              targetObjectName: targetObjectName,
              oppositePropertyName: variableSpecification.mustBeInsteadOf
            }
          )
        )

    else

      if (\
        isNonEmptyString(variableSpecification.mustBeInsteadOf) &&\
        isNotNull(getObjectValueByDotSeparatedPathSafely(targetObject, variableSpecification.mustBeInsteadOf))
      )

        error(
          buildString(
            "The properties '${targetPropertyDotSeparatedPath}' and '${oppositePropertyName}' are " +\
            "incompatible. Specify only one of them.",
            {
              targetPropertyDotSeparatedPath: variableSpecification.dotSeparatedPath,
              targetObjectName: targetObjectName,
              oppositePropertyName: variableSpecification.mustBeInsteadOf
            }
          )
        )

      if isNotNull(variableSpecification.incompatibleWith)

        for incompatiblePropertyDotSeparatedPath in variableSpecification.incompatibleWith

          if isNotNull(getObjectValueByDotSeparatedPathSafely(targetObject, incompatiblePropertyDotSeparatedPath))

            error(
              buildString(
                "The property '${ targetPropertyDotSeparatedPath }' is incompatible with the property " +\
                "${ incompatiblePropertyDotSeparatedPath } for the '${ targetObjectName }'.",
                {
                  targetPropertyDotSeparatedPath: variableSpecification.dotSeparatedPath,
                  incompatiblePropertyDotSeparatedPath: incompatiblePropertyDotSeparatedPath,
                  targetObjectName: targetObjectName
                }
              )
            )


      extractedVariables[variableFinalName] = targetValue

  return extractedVariables


validateAndAssignStoredInObjectCSS_Properties(compoundParameter, restParameters__MUST_NOT_BE...)

  validateObjectTypeParameter({
    mixinOrFunctionName: "validateAndAssignStoredInObjectCSS_Properties",
    targetParameterNumber: 1,
    targetParameter: compoundParameter,
    schema: {
      targetObjectName: {
        type: DataTypes.string,
        required: true,
        minimalCharactersCount: 1
      }
    },
    followingParametersWhichMustNotBe: restParameters__MUST_NOT_BE
  })

  extractedCSS_Declarations = extractAndValidateObjectProperties({
    targetObject: compoundParameter.targetObject,
    targetObjectName: compoundParameter.targetObjectName,
    extracts: compoundParameter.assigments
  })

  assignedCSS_Properties = null

  for propertyKey, propertySpecification in compoundParameter.assigments

    CSS_Key = isNonEmptyString(propertySpecification.newName) ? propertySpecification.newName : propertyKey

    if (isNotNull(compoundParameter.assigments[propertyKey].applier))

      // [ Stylus theory ] Functions in object are allowed but must be decomposed to be invoked.
      applier = compoundParameter.assigments[propertyKey].applier

      applier(extractedCSS_Declarations[CSS_Key])


    // [ Theory ] The CSS properties with same "newName" but different "propertyKey" could be.
    else if (!hasPrimitivesArraySpecifiedElement(assignedCSS_Properties, CSS_Key))

      value = extractedCSS_Declarations[CSS_Key]

      if isNotNull(value)

        {CSS_Key}: value

        push(assignedCSS_Properties, CSS_Key)


applyObjectTypeBoxShadowDefinition(compoundParameter, restParameters__MUST_NOT_BE...)

  // [ Stylus theory ] `isNull(compoundParameter) { return }` will not work.
  if isNotNull(compoundParameter)

    validateObjectTypeParameter({
      mixinOrFunctionName: "applyObjectTypeBoxShadowDefinition",
      targetParameterNumber: 1,
      targetParameter: compoundParameter,
      schema: {
        inset: {
          type: DataTypes.boolean,
          defaultValue: false
        },
        XOffset: {
          type: DataTypes.dimensionalQuantity,
          defaultValue: 0
        },
        YOffset: {
          type: DataTypes.dimensionalQuantity,
          defaultValue: 0
        },
        blurRadius: {
          type: DataTypes.dimensionalQuantity,
          defaultValue: 0
        },
        spreadRadius: {
          type: DataTypes.dimensionalQuantity,
          defaultValue: 0
        },
        color: {
          type: DataTypes.colorDefinition,
          required: true
        }
      },
      followingParametersWhichMustNotBe: restParameters__MUST_NOT_BE
    })

    box-shadow: unquote(
      isTrue(compoundParameter.inset) ? "inset " : "" +\
      buildString(
        "${XOffset} ${YOffset} ${blurRadius} ${spreadRadius} ${color}",
        compoundParameter
      )
    )


applyObjectTypeUnderlineDefinition(compoundParameter = {}, restParameters__MUST_NOT_BE...)

  validateObjectTypeParameter({
    mixinOrFunctionName: "applyObjectTypeUnderlineDefinition",
    targetParameterNumber: 1,
    targetParameter: compoundParameter,
    schema: {
      thickness: {
        type: DataTypes.dimensionalQuantity,
        required: false
      },
      type: {
        type: DataTypes.string,
        required: false,
        considerIdentifierAsString: true,
        allowedAlternatives: "solid" "double" "dotted" "dashed" "wavy"
      },
      color: {
        type: DataTypes.colorDefinition,
        required: false
      }
    },
    followingParametersWhichMustNotBe: restParameters__MUST_NOT_BE
  })

  if isNotNull(compoundParameter) && length(keys(compoundParameter)) > 0

    applyIfNotNull({
      text-decoration-style: compoundParameter.type,
      text-decoration-thickness: compoundParameter.thickness
      text-decoration-color: compoundParameter.color
    })


applyOutlineObjectTypeDefinition(compoundParameter = {}, restParameters__MUST_NOT_BE...)

  validateObjectTypeParameter({
    mixinOrFunctionName: "applyOutlineObjectTypeDefinition",
    targetParameterNumber: 1,
    targetParameter: compoundParameter,
    schema: {
      thickness: {
        type: DataTypes.dimensionalQuantity,
        required: false
      },
      type: {
        type: DataTypes.string,
        required: false,
        considerIdentifierAsString: true,
        allowedAlternatives: "dotted" "dashed" "solid" "double" "groove" "ridge" "inset" "outset"
      },
      color: {
        type: DataTypes.colorDefinition,
        required: false
      }
    },
    followingParametersWhichMustNotBe: restParameters__MUST_NOT_BE
  })


  if isNotNull(compoundParameter) && length(keys(compoundParameter)) > 0

    applyIfNotNull({
      outline-width: compoundParameter.thickness,
      outline-style: compoundParameter.type,
      outline-color: compoundParameter.color
    })
